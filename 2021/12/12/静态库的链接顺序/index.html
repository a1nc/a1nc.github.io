<!DOCTYPE html>
<html lang="zh-Hans,en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/a1nc.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/a1nc.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/a1nc.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/a1nc.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/a1nc.github.io/css/main.css">


<link rel="stylesheet" href="/a1nc.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/a1nc.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文翻译至：https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2013&#x2F;07&#x2F;09&#x2F;library-order-in-static-linking   I’ll start with a slightly sneaky but educational example. Suppose we have this code: 12345678910volatile char src[]">
<meta property="og:type" content="article">
<meta property="og:title" content="静态库的链接顺序">
<meta property="og:url" content="https://github.com/a1nc/2021/12/12/%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E9%93%BE%E6%8E%A5%E9%A1%BA%E5%BA%8F/index.html">
<meta property="og:site_name" content="a1nc&#39;s博客">
<meta property="og:description" content="本文翻译至：https:&#x2F;&#x2F;eli.thegreenplace.net&#x2F;2013&#x2F;07&#x2F;09&#x2F;library-order-in-static-linking   I’ll start with a slightly sneaky but educational example. Suppose we have this code: 12345678910volatile char src[]">
<meta property="og:locale">
<meta property="og:image" content="https://github.com/a1nc/2021/12/12/%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E9%93%BE%E6%8E%A5%E9%A1%BA%E5%BA%8F/images/posts/static_link_order/circdep2.png">
<meta property="article:published_time" content="2021-12-12T13:31:31.000Z">
<meta property="article:modified_time" content="2021-12-12T13:38:40.899Z">
<meta property="article:author" content="a1nc">
<meta property="article:tag" content="gcc">
<meta property="article:tag" content="编译链接">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/a1nc/2021/12/12/%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E9%93%BE%E6%8E%A5%E9%A1%BA%E5%BA%8F/images/posts/static_link_order/circdep2.png">

<link rel="canonical" href="https://github.com/a1nc/2021/12/12/%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E9%93%BE%E6%8E%A5%E9%A1%BA%E5%BA%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>静态库的链接顺序 | a1nc's博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/a1nc.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">a1nc's博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/a1nc.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/a1nc.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/a1nc.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/a1nc.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/a1nc.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://github.com/a1nc/2021/12/12/%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E9%93%BE%E6%8E%A5%E9%A1%BA%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/a1nc.github.io/images/avatar.png">
      <meta itemprop="name" content="a1nc">
      <meta itemprop="description" content="a1nc记录计算机、学习等相关内容的小站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="a1nc's博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          静态库的链接顺序
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-12 21:31:31 / 修改时间：21:38:40" itemprop="dateCreated datePublished" datetime="2021-12-12T21:31:31+08:00">2021-12-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/a1nc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<ul>
<li>本文翻译至：<a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2013/07/09/library-order-in-static-linking">https://eli.thegreenplace.net/2013/07/09/library-order-in-static-linking</a></li>
</ul>
</blockquote>
<p>I’ll start with a slightly sneaky but educational example. Suppose we have this code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">volatile char src[] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">volatile char dst[50] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">void* memcpy(void* dst, void* src, int len);</span><br><span class="line"></span><br><span class="line">int main(int argc, const char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    memcpy(dst, src, sizeof(src));</span><br><span class="line">    return dst[4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It runs just fine and the return value is 5. Now, suppose this is part of a larger project that consists of many object files and libraries, and somewhere within the project there’s a library that contains this code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void memcpy(char* aa, char* bb, char* cc) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; 100; ++i) &#123;</span><br><span class="line">        cc[i] = aa[i] + bb[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the previous snippet gets linked with this library, what happens? Would you expect it to still return 5? Return something else? Crash? The answer is: it depends - the result can be either correct or a segmentation fault. It depends on the order in which the objects and libraries in the project were fed to the linker.</p>
<p>If you fully understand why this depends on linking order, as well as how to avoid the problem (and more serious problems, like circular dependencies) then congratulate yourself and move on - this article is probably not for you. Otherwise, read on.</p>
<h3 id="The-basics"><a href="#The-basics" class="headerlink" title="The basics"></a>The basics</h3><p>Let’s start by defining the scope of this article: first, my examples are demonstrating the use of the gcc and binutils toolchain on Linux. Compatible toolchains (like clang instead of gcc) apply too. Second, the discussion here resolves around <em>static</em> linking that’s done at compile/link time.</p>
<p>To understand why linking order matters, it’s first instructional to understand how the linker works with respect to linking libraries and objects together. Just as a quick reminder - an object file both <em>provides</em> (exports) external symbols <em>to</em> other objects and libraries, and <em>expects</em> (imports) symbols <em>from</em> other objects and libraries. For example, in this C code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int imported(int);</span><br><span class="line"></span><br><span class="line">static int internal(int x) &#123;</span><br><span class="line">    return x * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int exported(int x) &#123;</span><br><span class="line">    return imported(x) * internal(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The names of the functions speak for themselves. Let’s compile it and look at the symbol table:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c x.c</span><br><span class="line">$ nm x.o</span><br><span class="line">000000000000000e T exported</span><br><span class="line">                 U imported</span><br><span class="line">0000000000000000 t internal</span><br></pre></td></tr></table></figure>

<p>This means: <code>exported</code> is an external symbol - defined in the object file and visible from the outside. <code>imported</code> is an undefined symbol; in other words, the linker is expected to find it elsewhere. When we talk about linking later, the term <em>undefined</em> can become confusing - so it helps to remember that this is where it comes from originally. <code>internal</code> is defined within the object but invisible from the outside.</p>
<p>Now, a <em>library</em> is simply a collection of object files. Just a bunch of object files glued together. Creating a library is a very trivial operation that doesn’t do anything special besides placing many object files into the same file. This in itself is important, because a horde of object files is not convenient to deal with. For example, on my system <code>libc.a</code> (the static version of the C library) consists of almost 1500 object files. It’s way nicer to just carry <code>libc.a</code> around.</p>
<h3 id="The-linking-process"><a href="#The-linking-process" class="headerlink" title="The linking process"></a>The linking process</h3><p>This section defines the linking process in a somewhat dry, algorithmic manner. This process is the key to understanding why linking order matters.</p>
<p>Consider a linker invocation:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc main.o -L/some/lib/dir -lfoo -lbar -lbaz</span><br></pre></td></tr></table></figure>

<p>The linker is almost always invoked through the compiler driver <code>gcc</code> when compiling C or C++ code. This is because the driver knows how to provide the correct command-line arguments to the linker itself (<code>ld</code>) with all the support libraries, etc. We’ll see more of this later.</p>
<p>Anyhow, as you can see the object files and libraries are provided in a certain order on the command-line, from left to right. This is the linking order. Here’s what the linker does:</p>
<ul>
<li>The linker maintains a</li>
</ul>
<p>  symbol table</p>
<p>  . This symbol table does a bunch of things, but among them is keeping two lists:</p>
<ul>
<li><p>A list of symbols exported by all the objects and libraries encountered so far.</p>
</li>
<li><p>A list of undefined symbols that the encountered objects and libraries requested to import and were not found yet.</p>
</li>
<li><p>When the linker encounters a new object file, it looks at:</p>
<ul>
<li>The symbols it exports: these are added to the list of exported symbols mentioned above. If any symbol is in the undefined list, it’s removed from there because it has now been found. If any symbol has already been in the exported list, we get a “multiple definition” error: two different objects export the same symbol and the linker is confused.</li>
<li>The symbols it imports: these are added to the list of undefined symbols, unless they can be found in the list of exported symbols.</li>
</ul>
</li>
<li><p>When the linker encounters a new library, things are a bit more interesting. The linker goes over all the objects in the library. For each one, it first looks at the symbols it exports.</p>
<ul>
<li>If any of the symbols it exports are on the undefined list, the object is added to the link and the next step is executed. Otherwise, the next step is skipped.</li>
<li>If the object has been added to the link, it’s treated as described above - its undefined and exported symbols get added to the symbol table.</li>
<li>Finally, if <em>any</em> of the objects in the library has been included in the link, the library is rescanned again - it’s possible that symbols imported by the included object can be found in other objects within the same library.</li>
</ul>
</li>
</ul>
<p>When the linker finishes, it looks at the symbol table. If any symbols remain in the undefined list, the linker will throw an “undefined reference” error. For example, when you create an executable and forget to include the file with the <code>main</code> function, you’ll get something like:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/x86_64-linux-gnu/crt1.o: In function &#x27;_start&#x27;:</span><br><span class="line">(.text+0x20): undefined reference to &#x27;main&#x27;</span><br><span class="line">collect2: ld returned 1 exit status</span><br></pre></td></tr></table></figure>

<p>Note that after the linker has looked at a library, it won’t look at it again. Even if it exports symbols that may be needed by some later library. The only time where a linker goes back to rescan objects it has already seen happens within a single library - as mentioned above, once an object from some library is taken into the link, all other objects in the same library will be rescanned. Flags passed to the linker can tweak this process - again, we’ll see some examples later.</p>
<p>Also note that when a library is examined, an object file within it can be left out of the link if it does not provide symbols that the symbol table needs. This is a very important feature of static linking. The C library I mentioned before makes a heavy use of this feature, by mostly splitting itself to an-object-per-function. So, for example if the only C standard library function your code uses is <code>strlen</code>, only <code>strlen.o</code> will be taken into the link from <code>libc.a</code> - and your executable will be very small.</p>
<h3 id="Simple-examples"><a href="#Simple-examples" class="headerlink" title="Simple examples"></a>Simple examples</h3><p>The previous section can be hard to digest, so here are some simple examples that show the process in action.</p>
<p>Let’s start with the most basic case, of linking two objects together:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat simplefunc.c</span><br><span class="line">int func(int i) &#123;</span><br><span class="line">    return i + 21;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ cat simplemain.c</span><br><span class="line">int func(int);</span><br><span class="line"></span><br><span class="line">int main(int argc, const char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    return func(argc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ gcc -c simplefunc.c</span><br><span class="line">$ gcc -c simplemain.c</span><br><span class="line">$ gcc simplefunc.o simplemain.o</span><br><span class="line">$ ./a.out ; echo $?</span><br><span class="line">22</span><br></pre></td></tr></table></figure>

<p>Everything links and works as expected. Note that since these are object files, the linking order does not matter. Object files are always taken into the link. We can pass them to the linker in reversed order and it still works:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc simplemain.o simplefunc.o</span><br><span class="line">$ ./a.out ; echo $?</span><br><span class="line">22</span><br></pre></td></tr></table></figure>

<p>Now let’s do something different. Let’s put <code>simplefunc.c</code> into a library:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ar r libsimplefunc.a simplefunc.o</span><br><span class="line">$ ranlib libsimplefunc.a</span><br><span class="line">$ gcc  simplemain.o -L. -lsimplefunc</span><br><span class="line">$ ./a.out ; echo $?</span><br><span class="line">22</span><br></pre></td></tr></table></figure>

<p>Works like a charm. But note what happens if the linking order is reversed now:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc  -L. -lsimplefunc  simplemain.o</span><br><span class="line">simplemain.o: In function &#x27;main&#x27;:</span><br><span class="line">simplemain.c:(.text+0x15): undefined reference to &#x27;func&#x27;</span><br><span class="line">collect2: ld returned 1 exit status</span><br></pre></td></tr></table></figure>

<p>Understanding the linking algorithm outlined above makes this case simple to explain. When the linker encounters <code>libsimplefunc.a</code>, it still hasn’t seen <code>simplemain.o</code>, which means that <code>func</code> is not yet on the undefined list. When the linker looks into the library it sees <code>simplefunc.o</code> that exports <code>func</code>. But since it doesn’t need <code>func</code>, this object file is not included in the link. When the linker does reach <code>simplemain.o</code> and sees that <code>func</code> is, indeed required, it’s added to the undefined list (because it’s not on the exported list). The linker then reaches the end of the link and <code>func</code> is still undefined.</p>
<p>Note how this doesn’t happen in the previous linking order - since <code>simplemain.o</code> comes first, <code>func</code> is on the undefined list <em>before</em> the linker sees the library, so the object file exporting it does get included.</p>
<p>This brings us to the most important corollary of the linking process outlined above:</p>
<blockquote>
<p>If object or library AA needs a symbol from library BB, then AA should come <em>before</em> library BB in the command-line invocation of the linker.</p>
</blockquote>
<h3 id="Circular-dependency"><a href="#Circular-dependency" class="headerlink" title="Circular dependency"></a>Circular dependency</h3><p>The corollary above is an important summary of the linking process - it’s certainly much more practical to keep in mind because it’s so short. But it makes one wonder - what happens if AA needs a symbol from BB, but BB also needs a symbol from AA? While officially this isn’t a good programming practice, in reality it happens quite a lot. But AA can’t come both before and after BB on the command-line, right? That’s just silly. Wait, is it, really?</p>
<p>Let’s see an example and start simple. Imagine that instead of <code>simplefunc.c</code>, the <code>func</code> symbol is provided thus:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cat func_dep.c</span><br><span class="line">int bar(int);</span><br><span class="line"></span><br><span class="line">int func(int i) &#123;</span><br><span class="line">    return bar(i + 1);</span><br><span class="line">&#125;</span><br><span class="line">$ cat bar_dep.c</span><br><span class="line">int func(int);</span><br><span class="line"></span><br><span class="line">int bar(int i) &#123;</span><br><span class="line">    if (i &gt; 3)</span><br><span class="line">        return i;</span><br><span class="line">    else</span><br><span class="line">        return func(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>These two files depend on each other and get placed into different libraries. If we link them in one order, we fail:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc  simplemain.o -L.  -lbar_dep -lfunc_dep</span><br><span class="line">./libfunc_dep.a(func_dep.o): In function &#x27;func&#x27;:</span><br><span class="line">func_dep.c:(.text+0x14): undefined reference to &#x27;bar&#x27;</span><br><span class="line">collect2: ld returned 1 exit status</span><br></pre></td></tr></table></figure>

<p>However, the other order does work:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc  simplemain.o -L. -lfunc_dep -lbar_dep</span><br><span class="line">$ ./a.out ; echo $?</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>Quiz: can you figure out why? Hint: just go over the linking process algorithm with this command-line. What undefined symbols does the symbol table contain when the linker first sees <code>-lfunc_dep</code>?</p>
<p>But this is a very simple case. Let’s look at a trickier one. We’ll add a dependency to <code>bar</code> on another function from <code>libfunc_dep.a</code>, but one that lives in a different object:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cat bar_dep.c</span><br><span class="line">int func(int);</span><br><span class="line">int frodo(int);</span><br><span class="line"></span><br><span class="line">int bar(int i) &#123;</span><br><span class="line">    if (i &gt; 3)</span><br><span class="line">        return frodo(i);</span><br><span class="line">    else</span><br><span class="line">        return func(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ cat frodo_dep.c</span><br><span class="line">int frodo(int i) &#123;</span><br><span class="line">    return 6 * i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’ll recompile all these files into separate objects, and the <code>libfunc_dep.a</code> library will now be:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ar r libfunc_dep.a func_dep.o frodo_dep.o</span><br><span class="line">$ ranlib libfunc_dep.a</span><br></pre></td></tr></table></figure>

<p>Here’s a drawing of the libraries, with arrows showing the dependencies:</p>
<p><img src="images/posts/static_link_order/circdep2.png" alt="img"></p>
<p>Now linking fails no matter what order we list the libraries in:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gcc  -L. simplemain.o -lfunc_dep -lbar_dep</span><br><span class="line">./libbar_dep.a(bar_dep.o): In function &#x27;bar&#x27;:</span><br><span class="line">bar_dep.c:(.text+0x17): undefined reference to &#x27;frodo&#x27;</span><br><span class="line">collect2: ld returned 1 exit status</span><br><span class="line">$ gcc  -L. simplemain.o -lbar_dep -lfunc_dep</span><br><span class="line">./libfunc_dep.a(func_dep.o): In function &#x27;func&#x27;:</span><br><span class="line">func_dep.c:(.text+0x14): undefined reference to &#x27;bar&#x27;</span><br><span class="line">collect2: ld returned 1 exit status</span><br></pre></td></tr></table></figure>

<p>To solve this, consider that it’s perfectly valid to list a library more than once on the link line; so in fact, we can provide <code>libfunc_dep.a</code> both before and after <code>libbar_dep.a</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc  -L. simplemain.o -lfunc_dep -lbar_dep -lfunc_dep</span><br><span class="line">$ ./a.out ; echo $?</span><br><span class="line">24</span><br></pre></td></tr></table></figure>

<p>Another quiz: will the same trick work providing <code>-lbar_dep</code> twice? Why not?</p>
<h3 id="Using-linker-flags-to-control-the-process"><a href="#Using-linker-flags-to-control-the-process" class="headerlink" title="Using linker flags to control the process"></a>Using linker flags to control the process</h3><p>As I’ve mentioned above, the linker has a number of interesting flags that can be used to control the process in a fine-grained manner. For example, circular dependency problems can be easily resolved with <code>--start-group</code> and <code>--end-group</code>. Here’s an instructive portion from <code>man ld</code>:</p>
<blockquote>
<p><strong>–start-group archives –end-group</strong></p>
<p>The specified archives are searched repeatedly until no new undefined references are created. Normally, an archive is searched only once in the order that it is specified on the command line. If a symbol in that archive is needed to resolve an undefined symbol referred to by an object in an archive that appears later on the command line, the linker would not be able to resolve that reference. By grouping the archives, they all be searched repeatedly until all possible references are resolved.</p>
<p>Using this option has a significant performance cost. It is best to use it only when there are unavoidable circular references between two or more archives.</p>
</blockquote>
<p>Here’s how this helps in our case:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc simplemain.o -L. -Wl,--start-group -lbar_dep -lfunc_dep -Wl,--end-group</span><br><span class="line">$ ./a.out ; echo $?</span><br><span class="line">24</span><br></pre></td></tr></table></figure>

<p>It’s interesting to note the “significant performance cost” warning in the excerpt above. This explains <em>why</em> the linking process is the way it is. Presumably, linkers could just re-scan the whole library list until no new symbols got resolved. This would eliminate most circular-dependency and linking order problems in the world, but it would also be slow. Linking is already a critical part of the compilation time of large systems, since it looks at the whole program and requires quite a bit of memory. It’s better to make it as fast as possible for well-behaved programs (that got their linking order right), and provide special options like groups for the difficult circular dependency cases.</p>
<p>There’s at least one another linker flag that can help us resolve the circular dependency here. We can use the <code>--undefined</code> flag to tell the linker - “buddy, here’s a symbol I want you to add to the undefined list”. In our case this makes the link error go away even though the libraries are specified only once:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc simplemain.o -L. -Wl,--undefined=bar -lbar_dep -lfunc_dep</span><br><span class="line">$ ./a.out ; echo $?</span><br><span class="line">24</span><br></pre></td></tr></table></figure>

<p>Figuring out why this works is left as an exercise to the reader.</p>
<h3 id="Back-to-the-original-example"><a href="#Back-to-the-original-example" class="headerlink" title="Back to the original example"></a>Back to the original example</h3><p>Let’s go back to the example this article started with. <code>main</code> assumes it gets the correct <code>memcpy</code> from the C library, but the <code>memcpy</code> it gets linked with does something else. Assuming the <code>memcpy</code> here was packed into the <code>libstray_memcpy.a</code> library:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc  -L. main_using_memcpy.o -lstray_memcpy</span><br><span class="line">$ ./a.out</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>

<p>This is the expected behavior. Since <code>-lstray_memcpy</code> was provided after <code>main_using_memcpy.o</code> on the command-line, it gets linked in. But what happens if the order is reversed:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc  -L. -lstray_memcpy main_using_memcpy.o</span><br><span class="line">$ ./a.out ; echo $?</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>The program links and works correctly. The reason for this is simple: even without us explicitly asking for it, gcc asks the linker to link the C library as well. The full linker invocation command of gcc is pretty complex, and can be examined by passing the <code>-###</code> flag to gcc. But in our case this amounts to:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc  -L. -lstray_memcpy main_using_memcpy.o -lc</span><br></pre></td></tr></table></figure>

<p>When the linker sees <code>-lstray_memcpy</code>, the symbol table does not yet have an undefined entry for <code>memcpy</code>, so the object file with the wrong function does not get linked. The linker adds this undefined entry only after it sees <code>main_using_memcpy.o</code>. Then, when it reaches <code>-lc</code>, the object file holding <code>memcpy</code> from the C library <em>does</em> get linked in because by now <code>memcpy</code> is on the undefined list.</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>The algorithm used by the linker to resolve symbols between objects and libraries is pretty simple. As long as you keep it in mind, linker errors and related problems should be easy to understand. If you still run into problematic situations you’re not sure how to resolve, this article mentioned two tools that can be very useful in debugging such problems: one is <code>nm</code>, which shows the symbol table of an object or a whole library. The other is the <code>-###</code> flag that gcc accepts and as a result shows the full commands it passes to the underlying tools.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/a1nc.github.io/tags/gcc/" rel="tag"># gcc</a>
              <a href="/a1nc.github.io/tags/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/" rel="tag"># 编译链接</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/a1nc.github.io/2021/12/12/hello-c/" rel="prev" title="Hello c">
      <i class="fa fa-chevron-left"></i> Hello c
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-basics"><span class="nav-number">1.</span> <span class="nav-text">The basics</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-linking-process"><span class="nav-number">2.</span> <span class="nav-text">The linking process</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Simple-examples"><span class="nav-number">3.</span> <span class="nav-text">Simple examples</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Circular-dependency"><span class="nav-number">4.</span> <span class="nav-text">Circular dependency</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-linker-flags-to-control-the-process"><span class="nav-number">5.</span> <span class="nav-text">Using linker flags to control the process</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Back-to-the-original-example"><span class="nav-number">6.</span> <span class="nav-text">Back to the original example</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Conclusion"><span class="nav-number">7.</span> <span class="nav-text">Conclusion</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="a1nc"
      src="/a1nc.github.io/images/avatar.png">
  <p class="site-author-name" itemprop="name">a1nc</p>
  <div class="site-description" itemprop="description">a1nc记录计算机、学习等相关内容的小站</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/a1nc.github.io/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/a1nc.github.io/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/a1nc.github.io/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">a1nc</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/a1nc.github.io/lib/anime.min.js"></script>
  <script src="/a1nc.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/a1nc.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/a1nc.github.io/js/utils.js"></script>

<script src="/a1nc.github.io/js/motion.js"></script>


<script src="/a1nc.github.io/js/schemes/pisces.js"></script>


<script src="/a1nc.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
